using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;


namespace CompiledResourceGenerator
{
    [Generator]
    public class CompiledResourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context) { }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.projectdir", out string? projectDirPath)) return;
            INamedTypeSymbol? byteSymbol = context.Compilation.GetTypeByMetadataName("System.Byte");
            if (byteSymbol is null) return;
            IArrayTypeSymbol byteArraySymbol = context.Compilation.CreateArrayTypeSymbol(byteSymbol);
            IEnumerable<ClassDeclarationSyntax> classNodes = context.Compilation.SyntaxTrees.SelectMany(static tree => tree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>());
            foreach (ClassDeclarationSyntax classNode in classNodes)
            {
                SemanticModel semanticModel = context.Compilation.GetSemanticModel(classNode.SyntaxTree);
                if (semanticModel.GetDeclaredSymbol(classNode) is not { } declaredClass) continue;
                IEnumerable<MethodDeclarationSyntax> methods = classNode.DescendantNodes().OfType<MethodDeclarationSyntax>().Where(static method => method.AttributeLists.Count > 0);
                CompilationUnitSyntax compilationUnit = CompilationUnit();
                NamespaceDeclarationSyntax @namespace = NamespaceDeclaration(IdentifierName(declaredClass.ContainingNamespace.ToDisplayString()))
                    .WithLeadingTrivia(TriviaList(Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)), Comment("// <auto-generated/>")).NormalizeWhitespace());
                ClassDeclarationSyntax @class = ClassDeclaration(declaredClass.Name).WithModifiers(SyntaxTokenList.Create(Token(SyntaxKind.PartialKeyword)));
                foreach (MethodDeclarationSyntax method in methods)
                {
                    IEnumerable<AttributeSyntax> attributes = method.AttributeLists.SelectMany(static x => x.Attributes);
                    AttributeSyntax? compiledResourceAttribute = attributes.FirstOrDefault(x => semanticModel.GetTypeInfo(x).Type?.Name == nameof(CompiledResourceAttribute));
                    if (compiledResourceAttribute?.ArgumentList is null) continue;
                    if (semanticModel.GetDeclaredSymbol(method) is not { } declaredMethod) continue;
                    if (!declaredMethod.IsPartialDefinition || !declaredMethod.IsStatic || declaredMethod.IsAbstract || declaredMethod.Parameters.Length != 0 || declaredMethod.Arity != 0 || declaredMethod.DeclaredAccessibility == Accessibility.NotApplicable || !SymbolEqualityComparer.Default.Equals(declaredMethod.ReturnType, byteArraySymbol)) continue;
                    SeparatedSyntaxList<AttributeArgumentSyntax> args = compiledResourceAttribute.ArgumentList.Arguments;
                    if (args.Count != 1 || args[0].Expression is not LiteralExpressionSyntax) continue;
                    Optional<object?> path = semanticModel.GetConstantValue(args[0].Expression);
                    if (!path.HasValue || path.Value is not string s) continue;
                    MethodDeclarationSyntax methodBody = MethodDeclaration(ParseTypeName("byte[]"), declaredMethod.Name)
                        .WithModifiers(ToToken(declaredMethod.DeclaredAccessibility))
                        .AddModifiers(Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.PartialKeyword)).WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
                    string filePath = Path.Combine(projectDirPath, s);
                    byte[] bytes = File.ReadAllBytes(filePath);
                    SeparatedSyntaxList<ExpressionSyntax> initializer = new();
                    initializer = initializer.AddRange(bytes.Select(static b => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(b))));
                    string fieldName = $"__BytesOf{declaredMethod.Name}";
                    FieldDeclarationSyntax bytesField = FieldDeclaration(
                        VariableDeclaration(ParseTypeName("byte[]"),
                        SingletonSeparatedList(
                            VariableDeclarator(fieldName)
                                .WithInitializer(
                                    EqualsValueClause(ObjectCreationExpression(ParseTypeName("byte[]"), null, InitializerExpression(SyntaxKind.ArrayInitializerExpression, initializer)))))))
                        .WithModifiers(new SyntaxTokenList(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.ReadOnlyKeyword)))
                        .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
                    methodBody = methodBody.WithExpressionBody(ArrowExpressionClause(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName(declaredClass.Name), IdentifierName(fieldName))));
                    compilationUnit = compilationUnit.AddMembers(@namespace.AddMembers(@class.AddMembers(methodBody, bytesField)));
                }

                context.AddSource($"{declaredClass.Name}.g.cs", compilationUnit.NormalizeWhitespace().ToFullString());
            }
        }

        private static SyntaxTokenList ToToken(Accessibility accessibility) => accessibility switch
        {
            Accessibility.Private => SyntaxTokenList.Create(Token(SyntaxKind.PrivateKeyword)),
            Accessibility.Public => SyntaxTokenList.Create(Token(SyntaxKind.PublicKeyword)),
            Accessibility.Protected => SyntaxTokenList.Create(Token(SyntaxKind.ProtectedKeyword)),
            Accessibility.Friend or Accessibility.Internal => SyntaxTokenList.Create(Token(SyntaxKind.InternalKeyword)),
            Accessibility.ProtectedAndFriend or Accessibility.ProtectedAndInternal => new SyntaxTokenList(Token(SyntaxKind.ProtectedKeyword), Token(SyntaxKind.InternalKeyword)),
            _ => throw new ArgumentOutOfRangeException(nameof(accessibility))
        };
    }
}
